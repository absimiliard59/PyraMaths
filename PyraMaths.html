<html>
	<head>
        <title>Pyramaths</title>
        <meta charset="UTF-8">
        <link href="https://fonts.googleapis.com/css?family=Bangers" rel="stylesheet"> 
        <link rel="stylesheet" href="css/style.css" />

		<style>	        
        		
        </style>
        
	</head>
	<body onload="init();">
		<script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/createjs-2015.05.21.min.js"></script>
        <script src="js/tween.min.js"></script>
        <script src="js/Controle.js"></script>
        <script src="js/STLloader.js"></script>
        <script src="js/dialogue.js"></script>
        <script src="js/puzzle_1.js"></script>
        <script src="js/puzzle_2.js"></script>
        <script src="js/puzzle_3.js"></script>
        <script src="js/puzzle_4.js"></script>
        <script src="js/puzzle_5.js"></script>
        <script src="js/utils.js"></script>
        <script src="js/inventaire.js"></script>
        <script src="js/Chargeur.js"></script>

        
		<script>
            var Main_Scale;
            var temps=3600
            var montre;
            var images,textures,Ch;
            var scene,spotLight,pyramide;
            var stage_enigme,stage_controleur,stage_inventaire,renderer;          
            var camera //la camera de la scene 3D
            var tremble=0 //permet de gérer le tremblement de la caméra
            var tremble2=0 //idem pour Main_enigme
            var current; //objet en cours de selection
            var freeze=false // permet de bloquer le clavier;           
            var rotation=0; //variable controlant la rotation de la camera 0,90,-90,180
            var pos_l,pos_c //la position de la caméra dans le tableau laby
            var eng,controleur,inv //les canvas pour l'énigme, le dialogue et l'inventaire
            var Main_control //le container de base du controler (nécessaire pour redimensionner)
            var Main_enigme //le container de base de l'énigme (nécessaire pour redimensionner)
            var Main_inventaire //idem pour l'inventaire
            var phara //container du pharaon
            var objets // l'inventaire
            var big_enigme; //liste des enigmes sur canvas
            var small_enigme=[]
            var liste_stel=[]; //liste des steles;
            var liste_mom=[]; //listes des momies;
            var liste_objets=[]; //listes des objets;                     
            var mode="laby" //ou "enigme" si le joueur est en train de résoudre une énigme.
            var premier_objet=true;


            small_enigme.push(["AAAHHH! Tu ne passeras que si tu sais résoudre cette énigme !\rJe suis un nombre à 4 chiffres, dont le nombre de centaines vaut le double du chiffre pair des unités.\nMon chiffre des dizaines est compris entre celui des centaines et des unités, et c'est le seul.\nQui suis-je ?","1678"])
        
            
            
            var Laby=[
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,4,1,0,1,1,1,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,5,0,0,0,0,1,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,2,1,0,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,0,1,0,1,1,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                ]
            
            
          
            
        function init() {

             eng = document.getElementById("eng"); 
             stage_enigme = new createjs.Stage(eng);
             createjs.Ticker.addEventListener("tick", stage_enigme); // pour que la scene1 soit redessinée à chaque "tick"

             Ch=new Chargement();
             Ch.x=400
             Ch.y=150
             stage_enigme.addChild(Ch)

	       
	       images = images||{};
           textures =textures ||{}

	       var manifest = [
		     
              {src:"images/mur.jpg", id:"mur"},
              {src:"images/mur2.jpg", id:"mur2"},
              {src:"images/mur3.jpg", id:"mur3"},
              {src:"images/sand.jpg", id:"sand"},
              {src:"images/momie.png", id:"momie"},
              {src:"images/compagnon.png", id:"compagnon"},
              {src:"images/cuir.png", id:"cuir"},
              {src:"images/serpent.png", id:"serpent"},
              {src:"images/pierre.jpg", id:"pierre"},
              {src:"images/gemme_bleu.png", id:"gemme_bleu"},
              {src:"images/gemme_rouge.png", id:"gemme_rouge"},
              {src:"images/gemme_verte.png", id:"gemme_verte"},
              {src:"images/gemme_jaune.png", id:"gemme_jaune"},
              {src:"images/gemme_blanche.png", id:"gemme_blanche"},
              {src:"images/stele.png", id:"stele"},
              {src:"images/scarabe.png", id:"scarabe"},
              {src: "images/empreinte_f.png", id:"empreinte_f"},
              {src: "images/empreinte_p.png", id:"empreinte_p"},
              {src: "images/galet.png", id:"galet"},
              {src: "images/papyrus.png", id:"papyrus"},
              {src: "images/papyrus2.jpg", id:"papyrus2"},
              {src: "images/sablier.png", id:"sablier"},
              {src: "images/urne.png", id:"urne"},
              {src: "images/piece3d.png", id:"piece3d"},

             
               
	       ];

	       var loader = new createjs.LoadQueue(false);
           loader.addEventListener("fileload", handleFileLoad);
	       loader.addEventListener("complete", handleComplete);
           loader.addEventListener("progress", handleProgress);
	       loader.loadManifest(manifest);
            }

            function handleProgress(evt){  
            Ch.Pourcentage.text="Chargement "+Math.floor(evt.progress*100)+" %"
        }



        function handleFileLoad(evt) {
            if (evt.item.type == "image") { images[evt.item.id] = evt.result;
            let t=new THREE.Texture(evt.result );
            t.needsUpdate=true;
            textures[evt.item.id] = t }
            

        }            
        
        /////////////////////////////////////////////////////////// creation des stages //////////////////////////////////
        function handleComplete() {
            Ch.Clear();
            // Création de la scène 3D
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog("#000000", 0.0025, 5);
            var L=window.innerWidth*2/3
            Main_Scale=L/755
            
            camera = new THREE.PerspectiveCamera( 40, 755 / 400, 0.1, 1000 );
            renderer = new THREE.WebGLRenderer();
            
            renderer.setSize( L, 400*Main_Scale );
            document.body.appendChild( renderer.domElement );     
                
            camera.position.z = 0.5;
            camera.position.y = 0.5;           
            camera.position.x = 0;
        
            camera.lookAt(new THREE.Vector3( 0, 0.5, -1 ))
                    
            
            // placement du personnage
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==2){                    
                    camera.position.x=-10+1*j;
                    camera.position.z=-10+1*i+0.5;  
                    pos_l=i;
                    pos_c=j;
                    Laby[i][j]=0;
                    break;
                        }
                        }
                    }
            
            var light = new THREE.AmbientLight( 0x000020 ); 
            scene.add( light );
            
            spotLight = new THREE.PointLight(  0xFFFFFF,  1.5,  40,  20 ,0.5,0.5,2);
            spotLight.position.set( camera.position.x,  camera.position.y,  camera.position.z );
            scene.add( spotLight );
            
            pyramide=new THREE.Object3D();            
            scene.add(pyramide);
            render();
            ////////////////////////////////////////////////// CREATION DES ENIGMES //////////////////////////////////////////  
            big_enigme=[puzzle_1(),puzzle_2(),puzzle_3(),puzzle_4(),puzzle_5()]; //liste des enigmes sur canvas
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
            let cont=document.getElementById("enigme")
            eng = document.getElementById("eng");  
            inv = document.getElementById("inv");  
            controleur=document.getElementById("controleur");
            eng.width=renderer.domElement.width;
            eng.height=renderer.domElement.height;
            
            
            cont.style.left=window.innerWidth/6+"px";
            cont.style.top=(window.innerHeight-400*Main_Scale)/3+"px";
            controleur.width=renderer.domElement.width;
            controleur.height=renderer.domElement.height;
            controleur.style.left=window.innerWidth/6+"px";
            controleur.style.top=(window.innerHeight-400*Main_Scale)/3+"px";
            renderer.domElement.style.left=window.innerWidth/6+"px";
            renderer.domElement.style.top=(window.innerHeight-400*Main_Scale)/3+"px";
            
            inv.width=renderer.domElement.width;
            inv.style.left=window.innerWidth/6+"px";
            
            inv.style.top=(parseInt(controleur.style.top)+parseInt(controleur.height)+10)+"px";
            
            
                
            stage_controleur = new createjs.Stage(controleur);
            stage_inventaire = new createjs.Stage(inv);
            createjs.Ticker.timingMode = createjs.Ticker.RAF; // pour une animation Tween plus fluide             
            createjs.Ticker.addEventListener("tick", stage_controleur); // pour que la scene2 soit redessinée à chaque "tick"
            createjs.Ticker.addEventListener("tick", stage_inventaire); // pour que la scene3 soit redessinée à chaque "tick"
            createjs.Ticker.addEventListener("tick", createjs.Tween); // pour que Tween fonctionne après un Ticker.reset() au déchargement de l'exercice;
            createjs.Touch.enable(stage_enigme); 
            createjs.Touch.enable(stage_inventaire); 
            stage_enigme.enableMouseOver(); 
            stage_inventaire.enableMouseOver();
            stage_controleur.enableMouseOver(); 
            createjs.Touch.enable(stage_controleur); 
                            
            
            Main_control=new createjs.Container();
            stage_controleur.addChild(Main_control);
            let htmlElement=document.getElementById('reponse')
            let ch=new createjs.DOMElement(htmlElement); 
            ch.x=550;
            ch.y=300;
            Main_control.addChild(ch);
            Main_control.scaleX=Main_control.scaleY=Main_Scale;

            Main_enigme=new createjs.Container();
            stage_enigme.addChild(Main_enigme)
            Main_enigme.scaleX=Main_enigme.scaleY=Main_Scale;            

            Main_inventaire=new createjs.Container();
            stage_inventaire.addChild(Main_inventaire);
            Main_inventaire.scaleX=Main_inventaire.scaleY=Main_Scale;

            ////////////////////////// création et gestion de l'inventaire ////////////////////////////
            objets=inventaire();
            Main_inventaire.addChild(objets);
            objets.addEventListener("prendre",prise);
            objets.addEventListener("deposer",depose);
            objets.addEventListener("utiliser",utilise);

            function get_objet(L,C){
                for(let i=0;i<liste_objets.length;i++){
                    if(liste_objets[i].L==L && liste_objets[i].C==C){
                        return(liste_objets[i])
                    }
                }
            }

            function utilise(){               
                let enface_l=enface().l;
                let enface_c=enface().c  ;                
                let e=get_stele(enface_l,enface_c).enigme;    
                let o=objets.selected;   
                console.log(e.indice)
                console.log(o.objet.info.indice)           
                if(e.indice==o.objet.info.indice){                    
                    objets.deranger();
                    e.debloque();
                } else {
                    console.log("mauvais objet")
                }
            }

            function prise(e){  
                if(mode=="enigme"){mode="laby"}                          
                let enface_l=enface().l;
                let enface_c=enface().c ;              
                let o=get_objet(enface_l,enface_c);                
                o.prise(enface_l,enface_c);
                objets.ranger(o);
            }

            function depose(e){               
                let enface_l=enface().l;
                let enface_c=enface().c;
                
                if(Laby[enface_l][enface_c]==0){
                    let o=objets.deranger();
                    o.replace(enface_l,enface_c);
                    objets.prendre.alpha=1;
                }               
                
            }
            ////////////////////////////////////////////////////////////////////////////////////////    
                
            /*var orbit = new THREE.OrbitControls( camera, renderer.domElement );
            orbit.enableZoom = true;
            var light = new THREE.AmbientLight( 0x000000 ); 
            scene.add( light );
            document.getElementById("eng").style.display="none"*/
                
            /////////////////////// Dialogues /////////////////////////            
            phara=new createjs.Bitmap(images["compagnon"]);
            phara.scaleX=phara.scaleY=0.5
            //phara.x=650 x final
            phara.x=1000;
            phara.y=300 // y final          
            Main_control.addChild(phara);
            createjs.Tween.get(phara).wait(200).to({x:650},500).call(intro);
            
            
            //////////////////////// Création des objets ///////////////////////////
            let o1=[textures["serpent"],textures["scarabe"],textures["papyrus2"],textures["urne"],textures["piece3d"]]
            let o2=[images["serpent"],images["scarabe"],images["papyrus2"],images["urne"],images["piece3d"]]
            let o3=[0,1,2,3,4]
            let o4=[0.08,0.11,0.1,0.08,0.09]
            //let o4=[0.08,0.11,0.1,0.08] [serpent,scarabe,parpyrus2,urne]
                       
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==5){
                    let alea=Math.floor(o1.length*Math.random());
                    alea=0;
                    let t=o1[alea];
                    var objMaterial = new THREE.SpriteMaterial( { map: t, color: 0xffffff } );                
                    objMaterial.fog=true;
                    let c=Objet(1,3,1,objMaterial);
                    c.position.x=-10+1*j;
                    c.position.z=-10+1*i+0.5;
                    c.position.y=0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.2;
                    c.L=i;
                    c.C=j;      
                    pyramide.add(c); 
                    c.info={indice:o3[alea],bitmap:new createjs.Bitmap(o2[alea]),scale:o4[alea]}; //indice: l'indice dans big_enigme de l'énigme correspondant à cet objet, bitmap pour l'image de l'inventaire, scale pour le dimensionner dans l'inventaire
                    o1.splice(alea,1);
                    o2.splice(alea,1);
                    o3.splice(alea,1);
                    o4.splice(alea,1);
                    liste_objets.push(c);
                        }
                    }
                } 
            // LES OBJETS
            function Objet(l,L,h,material){  
                var sprite = new THREE.Sprite( material );    
                
                sprite.prise=function(l,d){   
                    freeze=true; 
                    Laby[l][d]=0;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }    
                
                sprite.replace=function(l,d){ 
                    freeze=true;   
                    Laby[l][d]=5;
                    sprite.position.x=-10+1*d;
                    sprite.position.z=-10+1*l+0.5;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    sprite.L=l;
                    sprite.C=d;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:0.35}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }  
                return(sprite);                           
            } 
            
            
            
            //////////////////////// Création des gemmes ///////////////////////////
            let gemmes=["gemme_bleu","gemme_rouge","gemme_verte","gemme_jaune","gemme_blanche"]        
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==4){
                    var t=textures[gemmes[0]];                   
                    var gMaterial = new THREE.SpriteMaterial( { map: t, color: 0xffffff } );                
                    gMaterial.fog=true;
                    let c=Gemme(1,3,1,gMaterial);
                    c.position.x=-10+1*j;
                    c.position.z=-10+1*i+0.5;
                    c.position.y=-0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.2;
                    c.L=i;
                    c.C=j;      
                    pyramide.add(c); 
                    c.info={indice:1000000,bitmap:new createjs.Bitmap(images[gemmes[0]]),scale:0.08}; //indice: l'indice dans big_enigme de l'énigme correspondant à cet objet, bitmap pour l'image de l'inventaire, scale pour le dimensionner dans l'inventaire
                    liste_objets.push(c);
                    gemmes.splice(0,1);
                    //Laby[i][j]=5
                        }
                    }
                } 
            function Gemme(l,L,h,material){  
                var sprite = new THREE.Sprite( material );    
                
                sprite.prise=function(l,d){  
                    freeze=true; 
                    Laby[l][d]=0;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }    

                sprite.appear=function(){
                    freeze=true; 
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:0.35}, 2000 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;                                        
                                            sprite.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                            sprite.position.z=c+0.05*Math.cos(Math.random()*6.28);
                                            let enface_l=enface().l;
                                            let enface_c=enface().c;    
                                            Laby[enface_l][enface_c]=5;                                           
                                        })
                                        
                                        .onComplete( ()=>{
                                            freeze=false;
                                            objets.prendre.alpha=1;


                                        })
                                    .delay(1000)
                                    .start();

                }
                
                sprite.replace=function(l,d){ 
                    freeze=true;   
                    Laby[l][d]=5;
                    sprite.position.x=-10+1*d;
                    sprite.position.z=-10+1*l+0.5;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    sprite.L=l;
                    sprite.C=d;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:0.35}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }  
                return(sprite);                           
            }
        
            //////////////////////// Création des stèles ///////////////////////////            
            var steleMaterial = new THREE.SpriteMaterial( { map: textures["stele"], color: 0xffffff } );
            steleMaterial.fog=true;
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==4){
                    let c=Stele(1,3,1,steleMaterial);
                    c.position.x=-10+1*j;
                    c.position.z=-10+1*i+0.5;
                    c.position.y=0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.7;
                    c.L=i;
                    c.C=j;
                    c.enigme=big_enigme[0];
                    liste_stel.push(c);
                    pyramide.add( c ); 
                    big_enigme.splice(0,1)
                    }
                    }
                }   
            function Stele(l,L,h,material){  
                var sprite = new THREE.Sprite( material );   
                
                sprite.disappear=function(){
                    freeze=true; 
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 3000 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;                                        
                                            sprite.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                            sprite.position.z=c+0.05*Math.cos(Math.random()*6.28)                                      
                                        } )
                                        
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();

                }
                
                return(sprite);                           
            }            
        
        
            ///////////////////////// Création des momies //////////////////////////////////////////////
            
            var momieMaterial = new THREE.SpriteMaterial( { map: textures["momie"], color: 0xffffff } );
            momieMaterial.fog=true;
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==3){
                    let c=Momie(1,3,1,momieMaterial);
                    c.position.x=-10+1*j;
                    c.position.z=-10+1*i+0.5;
                    c.position.y=0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.7
                    c.L=i;
                    c.C=j;
                    c.enigme=small_enigme[0];
                    liste_mom.push(c)
                    pyramide.add( c ); 
                    }
                    }
                }

            function Momie(l,L,h,material){ 
                var sprite = new THREE.Sprite( material ); 
                sprite.clear=function(b,l,d){
                    b.clear();
                    freeze=true;
                    document.getElementById("contenu").value="";
                    Laby[l][d]=0;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 2500 )
                                        .onUpdate( function () {                               
                                        sprite.position.y = this.y;
                                        sprite.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                        sprite.position.z=c+0.05*Math.cos(Math.random()*6.28)                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }          
                return(sprite);                          
            }
            
                        
            ///////////////////////// Création du sol/////////////////////////////////////////////////////////////////////////////
            let solTexture=textures["sand"];
            solTexture.wrapS = THREE.RepeatWrapping;
            solTexture.wrapT = THREE.RepeatWrapping;
            solTexture.repeat.set( 20, 20 );
            var solMaterial = new THREE.MeshPhongMaterial( { map: solTexture, color: 0xffffff } );
            let ground=Sol(20,0.01,20,solMaterial);
            pyramide.add( ground );    
            function Sol(l,L,h,material_sol){ 
                var geometry = new THREE.BoxGeometry( l,L,h );                
                this.cube = new THREE.Mesh( geometry, material_sol );                  
                return(this.cube);                        
            }      
            
            ///////////////////////// Création des murs et bordures /////////////////////////////////////////////////////////////////////////////
            var murMaterial1 = new THREE.MeshPhongMaterial( { map: textures["mur"], color:0xFFFFFF,specular: 0x000000, shininess: 10 } ); 
            var murMaterial2 = new THREE.MeshPhongMaterial( { map: textures["mur2"], color:0xFFFFFF,specular: 0x000000, shininess: 10 } ); 
            var murMaterial3 = new THREE.MeshPhongMaterial( { map: textures["mur3"], color:0xFFFFFF,specular: 0x000000, shininess: 10 } );  
            var bordMaterial = new THREE.MeshLambertMaterial( { color:0xFF6600} )          
            let count=0;
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==1){
                    count++;
                    let c;
                    if(count%2==0){
                        c=Cube(1,3,1,murMaterial1);
                    } else {
                        let r=Math.random();
                        if(r<0.25){
                        c=Cube(1,3,1,murMaterial2);}
                        if(r>0.75){
                        c=Cube(1,3,1,murMaterial3);   
                        }
                        if(r<=0.75 && r>=0.25){
                        c=Cube(1,3,1,murMaterial1);   
                        }
                    }
                    c.position.x=-10+1*j;
                    c.position.z=-10+1*i+0.5;
                    c.position.y=0.5;
                    pyramide.add( c ); 
                    let  b=Bord(0.5,0.2,0.05,0.05,bordMaterial)                    
                    b.position.x=-10+1*j;
                    b.position.z=-10+1*i;
                    b.position.y=0;
                    pyramide.add( b );
                    }
                    }
                }
            function Cube(l,L,h,material_mur){  
                var geometry = new THREE.BoxGeometry( l,L,h );               
                this.cube = new THREE.Mesh( geometry, material_mur );          
                this.cube.Shake=function(c){
                    var origine=c.position.clone();
                    function moove(){
                    c.position.x=origine.x+Math.random()*0.1
                    c.position.y=origine.y+Math.random()*0.1
                    c.position.z=origine.z+Math.random()*0.1
                    }
                    var r=window.setInterval(moove,50);
                    setTimeout(function(){window.clearInterval(r);c.position.x=origine.x;c.position.y=origine.y;c.position.z=origine.z},2000);
                    }            
                return(this.cube);          
                }
            function Bord(l,L,h,e,material){        
            var shape = new THREE.Shape();
                shape.moveTo( -l,h );
                shape.lineTo( l, h );
                shape.lineTo( l+e, 0 );
                shape.lineTo( -l-e, 0 );
                shape.lineTo( -l, h );
                var extrudeSettings = {
                    steps: 2,
                    amount: 1,                   
                    bevelEnabled: true,
                    bevelThickness: e,
                    bevelSize: e                   
                };
                var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );                              
                this.cube = new THREE.Mesh( geometry, material );                
                return(this.cube);                 
            } 
            //////////////////////////////////////////////////////////////////////////////////////////////
        
                
    
                
            document.onkeydown=keyPressed;
        }
                            
//            var bgtexture= THREE.ImageUtils.loadTexture( "images/background.jpg");            
//            var geometry = new THREE.PlaneGeometry( 90, 90, 32 );
//            var material = new THREE.MeshBasicMaterial( {map:bgtexture, side: THREE.DoubleSide} );
//            var plane = new THREE.Mesh( geometry, material );
//            plane.position.z=-30;
//            camera.add( plane );
//            scene.add(camera);            
            

        function get_stele(L,C){                         
            for(let i=0;i<liste_stel.length;i++){
                if(liste_stel[i].L==L && liste_stel[i].C==C){
                    return(liste_stel[i])
                }
            }
        }

        function get_momie(L,C){                         
            for(let i=0;i<liste_mom.length;i++){
                if(liste_mom[i].L==L && liste_mom[i].C==C){
                    return(liste_mom[i])
                }
            }
        }

        function get_objet(L,C){                         
            for(let i=0;i<liste_objets.length;i++){
                if(liste_objets[i].L==L && liste_objets[i].C==C){
                    return(liste_objets[i])
                }
            }
        }

        function detect_objet(dir){
            let obstacle=false                
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]==5){obstacle=true};break;
                case -90: if(Laby[pos_l][pos_c+1]==5){obstacle=true};break;
                case 90: if(Laby[pos_l][pos_c-1]==5){obstacle=true};break;
                case 180: if(Laby[pos_l+1][pos_c]==5){obstacle=true};break;
            }               
            return(obstacle);
        }
        

        function intro(){
            let b=dialogue("Bonjour, je m'appelle Khaal Culatris et je serai ton guide dans cette aventure.\nPour te déplacer dans ce labyrinthe, il te faut utiliser les flèches du clavier. \nUn inventaire pour l'instant vide se situe ci-dessous.\nTu en auras certainement besoin pour résoudre les énigmes qui te seront proposées.\nJe te conseille de plus de te munir d'une feuille de papier et d'un crayon.","qcm",["J'ai compris."],["#fc00ed"],["suite"]);
            b.x=640;
            b.y=330;            
            b.addEventListener("suite",()=>{b.clear();createjs.Tween.get(phara).wait(300).to({x:1000},500);montre=setInterval('chrono()',1000) })
            Main_control.addChild(b)
        }

        function chrono(){
            if(temps<0){
                temps=0;
                clearInterval(montre);
                alert("perdu !");
            }
            temps-=1;
            let min=Math.floor(temps/60);
            let sec=temps%60;
            document.getElementById("chr").innerHTML="Temps: "+min+"min "+sec+"s";
        }

        function first_objet(){            
            premier_objet=false;
            mode="enigme"
            freeze=true;
            let t="Bravo ! Tu viens de découvrir ton premier objet. \nTu peux le ranger dans ton inventaire.\nPar la suite, en le sélectionnant, tu pourras le déposer ou l'utiliser dans une énigme."
            let b=dialogue(t,"qcm",["J'ai compris."],["#fc00ed"],["suite"]);
            b.x=640;
            b.y=330;            
            b.addEventListener("suite",()=>{b.clear();objets.prendre.alpha=1;createjs.Tween.get(phara).wait(300).to({x:1000},500);})
            Main_control.addChild(b)
        }

        function trouve_stele(){
            let t="Une stèle étrange comporte un mécanisme. \nVeux-tu essayer de résoudre l'énigme qu'elle propose ?"
            let b=dialogue(t,"qcm",["OUI","NON"],["#fc00ed","#fc00ed"],["oui","non"]);
            b.x=640;
            b.y=330;   
            Main_control.addChild(b)         
            b.addEventListener("non",()=>{b.clear();createjs.Tween.get(phara).wait(300).to({x:1000},500);By_pass();mode="laby"})
            b.addEventListener("oui",()=>{  b.clear();
                                            mode="enigme";
                                            let enface_l=enface().l;
                                            let enface_c=enface().c;                                           
                                            createjs.Tween.get(phara).wait(300).to({x:1000},500);
                                            let e=get_stele(enface_l,enface_c).enigme;    
                                            e.x=-1000;  
                                            e.quitter.visible=false;                                                                        
                                            Main_enigme.addChild(e);                                               
                                            createjs.Tween.get(e).to({x:0},500)
                                            eng.style.zIndex=4000; 
                                            e.addEventListener("quitter",()=>{ 
                                                objets.reset(); 
                                                e.removeAllEventListeners()             
                                                createjs.Tween.get(e).to({x:1000},500).call(()=>{Main_enigme.removeChild(e);eng.style.zIndex=1000;By_pass();mode="laby" })
                                            })
                                            e.addEventListener("valider",()=>{
                                                if(e.evaluer()=="juste"){
                                                objets.reset();  
                                                e.removeAllEventListeners()             
                                                createjs.Tween.get(e).to({x:1000},500).call(()=>{
                                                    Main_enigme.removeChild(e);
                                                    eng.style.zIndex=1000;By_pass();
                                                    get_stele(enface_l,enface_c).disappear();
                                                    get_objet(enface_l,enface_c).appear();
                                                    mode="laby";
                                                    })  
                                                } else {
                                                    tremble2=10;
                                                    temps=temps-60;
                                                }
                                            })
                                            if(e.bloque==true){  
                                                objets.bloque=true;
                                                eng.style.zIndex=1000; 
                                                createjs.Tween.get(phara,{override:true}).to({x:650},500).call(()=>{
                                                    let t2="Le mécanisme ne semble pas fonctionner.\nPeut-être qu'un objet de ton inventaire serait utile ?"
                                                    let b2=dialogue(t2,"qcm",["OK"],["#fc00ed"],["ok"]);
                                                    b2.x=640;
                                                    b2.y=330;   
                                                    Main_control.addChild(b2)    
                                                    b2.addEventListener("ok",()=>{b2.clear();createjs.Tween.get(phara).wait(300).to({x:1000},500);eng.style.zIndex=4000;objets.bloque=false; e.quitter.visible=true;})
                                                    }
                                                )
                                            } else { e.quitter.visible=true;}
                            })
        }         
            
        var tw //la tween de déplacement

        function By_pass(){
            let enface_l=enface().l;
            let enface_c=enface().c           
            if(Laby[enface_l][enface_c]==0){
                freeze=true;
                let f1=camera.position.z
                let f2=camera.position.x                            

                if(rotation==0){                            
                    f1=camera.position.z-1;
                    pos_l--;
                    }
                if(rotation==180){                            
                    f1=camera.position.z+1;
                    pos_l++;
                                }
                if(rotation==90){                            
                    f2=camera.position.x-1; 
                    pos_c--;
                }
                if(rotation==-90){                            
                    f2=camera.position.x+1;  
                    pos_c++;
                }      

                tw=new TWEEN.Tween( { z:camera.position.z,x:camera.position.x  } )
                        .to( { z:f1,x:f2 }, 250 )
                        .onUpdate( function () {                               
                        camera.position.z = this.z;
                        spotLight.position.z=this.z;
                        camera.position.x = this.x;
                        spotLight.position.x=this.x;
                        } )
                        .onComplete( ()=>{freeze=false}
                            )
                    .start();
                }

        }

        function keyPressed(event) {  
            //console.log(event.keyCode)           
            if(mode=="enigme"){return false}
            if(freeze==false){
                objets.prendre.alpha= objets.utiliser.alpha=0.3;
                freeze=true;                   
                switch(event.keyCode) {
                    case 32:{
                        debug_laby();
                        freeze=false;
                        break;
                    }

                    case 37:{
                        let f=camera.rotation.y+3.1415/2;
                        rotation+=90
                        if(rotation>180){rotation=-90}
                        tw=new TWEEN.Tween( { y:camera.rotation.y   } )
                                .to( { y:f }, 250 )
                                .onUpdate( function () {                               
                                camera.rotation.y = this.y;
                                } )
                                .onComplete( ()=>{freeze=false}
                                    )
                            .start();

                    break;}
                        
                    case 39:{
                        rotation-=90
                        if(rotation<-90){rotation=180}
                        let f=camera.rotation.y-3.1415/2;
                        tw=new TWEEN.Tween( { y:camera.rotation.y   } )
                                .to( { y:f }, 250 )
                                .onUpdate( function () {                               
                                camera.rotation.y = this.y;
                                } )
                                .onComplete( ()=>{freeze=false}
                                    )
                            .start();

                    break;}
                        
                    case 38:{  
                        if(collision(rotation)=="obj" && premier_objet==true){
                            return false;
                        }                          
                        if((collision(rotation)=="rien" || collision(rotation)=="obj") ){      
                            
                            let f1=camera.position.z
                            let f2=camera.position.x                            

                            if(rotation==0){                            
                                f1=camera.position.z-1;
                                pos_l--;
                            }
                            if(rotation==180){                            
                                f1=camera.position.z+1;
                                pos_l++;
                            }
                            if(rotation==90){                            
                                f2=camera.position.x-1; 
                                pos_c--;
                            }
                            if(rotation==-90){                            
                                f2=camera.position.x+1;  
                                pos_c++;
                            }
                         
                            tw=new TWEEN.Tween( { z:camera.position.z,x:camera.position.x  } )
                                    .to( { z:f1,x:f2 }, 250 )
                                    .onUpdate( function () {                               
                                    camera.position.z = this.z;
                                    spotLight.position.z=this.z;
                                    camera.position.x = this.x;
                                    spotLight.position.x=this.x;
                                    } )
                                    .onComplete( ()=>{freeze=false}
                                        )
                                .start();
                        } else {
                            //debug_laby();
                            let enface_l=enface().l;
                            let enface_c=enface().c;                            
                            if(Laby[enface_l][enface_c]==4){
                                createjs.Tween.get(phara).to({x:650},500).call(trouve_stele);
                                                                    
                            }
                            if(Laby[enface_l][enface_c]==3){
                                let e=get_momie(enface_l,enface_c).enigme;                                   
                                let b=dialogue(e[0],"momie",[e[1]],["#fc00ed"],["suite"]);
                                b.x=20;
                                b.y=20;            
                                b.addEventListener("faux",()=>{tremble=0.3;temps-=60;});
                                b.addEventListener("vrai",()=>{                                        
                                    get_momie(enface_l,enface_c).clear(b,enface_l,enface_c);
                                });
                                Main_enigme.addChild(b)                                    
                            }
                            if(collision(rotation)=="obj"){                                                                      
                                objets.prendre.alpha=1;
                            }

                            if(Laby[enface_l][enface_c]==1){
                            freeze=false
                            }
                        }
                    
                    break;}
                    case 40:{
                        objets.prendre.alpha= objets.utiliser.alpha=0.3;
                        let r;
                        if(rotation==90 || rotation==-90){r=-rotation}
                        if(rotation==0){r=180}
                        if(rotation==180){r=0}
                        if(collision(r)=="rien" || collision(rotation)=="obj"){
                            //Laby[pos_l][pos_c]=0;
                            let f1=camera.position.z
                            let f2=camera.position.x                            

                            if(rotation==0){                            
                                f1=camera.position.z+1;
                                pos_l++;
                            }
                            if(rotation==180){                            
                                f1=camera.position.z-1;
                                pos_l--;
                            }
                            if(rotation==90){                            
                                f2=camera.position.x+1; 
                                pos_c++;
                            }
                            if(rotation==-90){                            
                                f2=camera.position.x-1;  
                                pos_c--;
                            }
                            //Laby[pos_l][pos_c]=2;
                            //debug_laby();
                            tw=new TWEEN.Tween( { z:camera.position.z,x:camera.position.x  } )
                                    .to( { z:f1,x:f2 }, 250 )
                                    .onUpdate( function () {                               
                                    camera.position.z = this.z;
                                    spotLight.position.z=this.z;
                                    camera.position.x = this.x;
                                    spotLight.position.x=this.x;
                                    } )
                                    .onComplete( ()=>{freeze=false}
                                        )
                                .start();
                        } else {freeze=false}
                    
                    break;}
                    default: freeze=false;
                }
            }
            
            if(detect_objet(rotation)){
                objets.prendre.alpha=1;
                if(premier_objet==true){
                    freeze=true;
                    premier_objet=false;
                    objets.prendre.alpha=0.3;
                    createjs.Tween.get(phara).to({x:650},500);
                    first_objet();                                                                    
                    }
            }
        }
            
        function collision(dir){
            let obstacle="rien"
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]!=0){obstacle="mur"};break;
                case -90: if(Laby[pos_l][pos_c+1]!=0){obstacle="mur"};break;
                case 90: if(Laby[pos_l][pos_c-1]!=0){obstacle="mur"};break;
                case 180: if(Laby[pos_l+1][pos_c]!=0){obstacle="mur"};break;
            }
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]==5){obstacle="obj"};break;
                case -90: if(Laby[pos_l][pos_c+1]==5){obstacle="obj"};break;
                case 90: if(Laby[pos_l][pos_c-1]==5){obstacle="obj"};break;
                case 180: if(Laby[pos_l+1][pos_c]==5){obstacle="obj"};break;
            }
            
            return(obstacle);
            
        }

        function enface(){
            let enface_l=pos_l
            let enface_c=pos_c
            if(rotation==0){                           
                enface_l--;                                 
            }
            if(rotation==180){                            
                enface_l++;
            }
            if(rotation==90){                            
                enface_c--;
            }
            if(rotation==-90){                            
                enface_c++;
            }
            return({l:enface_l,c:enface_c});
        }
            
  
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // fonction de rendu  
        function render() {
            requestAnimationFrame( render );   
            //renderer.render(backgroundScene , backgroundCamera );
            renderer.render( scene, camera );
            TWEEN.update();
            if(tremble>0){                   
                camera.position.x=-10+1*pos_c+tremble*Math.cos(6.28*Math.random());
                camera.position.z=-10+1*pos_l+0.5+tremble*Math.cos(6.28*Math.random());                
                tremble=tremble-0.01
                }     
            if(tremble2>0){      
                Main_enigme.x=tremble2*Math.cos(6.28*Math.random());
                Main_enigme.y=tremble2*Math.cos(6.28*Math.random());
                tremble2=tremble2-0.1
                }     
            
        }        
        
        /////////////////////////////// fonction de debu Laby
        function debug_laby(){ 
            for(let i=0;i<Laby.length;i++){
                    let l=""
                    for(let j=0;j<Laby.length;j++){
                        l=l+Laby[i][j];
                    } 
                    console.log(l)
                }
        }
                        
           
            
		</script>
        
   
    <canvas id="controleur" width="200" height="400" style="position: absolute; z-index: 2000;"></canvas>
    <canvas id="inv" width="735" height="60" style="position: absolute; z-index: 3000;"></canvas>
    <div id="enigme" style="position: absolute;">
        <canvas id="eng" width="800" height="400" style="position: absolute; z-index: 1000;"></canvas>        
        <form id="reponse" class="popup">
        Réponse:<input class="champ" id="contenu" type="text" name="fname" maxlength="12">
        <input id="envoyer" class="bouton" type="button" value="OK">
    </form> 
    </div>
    <p class="chrono" id="chr">Temps: 60min</p>        
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="position: absolute; right:0"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /></a>.
    
    </body>
    
</html>