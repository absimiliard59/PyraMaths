<html>
	<head>
        <title>Pyramaths</title>
        <meta charset="UTF-8">
        <link href="https://fonts.googleapis.com/css?family=Bangers" rel="stylesheet"> 
        <link rel="stylesheet" href="css/style.css" />

		<style>	        
        		
        </style>
        
	</head>
	<body onload="init();">
		<script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/createjs-2015.05.21.min.js"></script>
        <script src="js/tween.min.js"></script>               
        <script src="js/dialogue.js"></script>
        <script src="js/puzzle_1.js"></script>
        <script src="js/puzzle_2.js"></script>
        <script src="js/puzzle_3.js"></script>
        <script src="js/puzzle_4.js"></script>
        <script src="js/puzzle_5.js"></script>
        <script src="js/utils.js"></script>
        <script src="js/inventaire.js"></script>
        <script src="js/Chargeur.js"></script>
        <script src="js/laby.js"></script>
        <script src="js/textes.js"></script>
        <script src="js/page_titre.js"></script>
        <script src="js/page_fin.js"></script>
        <script src="js/page_victoire.js"></script>

        
		<script>
            var Main_Scale;
            var temps=7200
            var montre;
            var images,textures,Ch;
            var scene,spotLight,pyramide;
            var stage_enigme,stage_controleur,stage_inventaire,stage_texture,renderer;   
            var emplacement,sortie;
            var canvas_texture;       
            var camera //la camera de la scene 3D
            var controls //orbital controle 
            var light_controls //lumiere ajoutée
            var save_position //la position et l'ange de la caméra avant passage à l'orbital
            var tremble=0 //permet de gérer le tremblement de la caméra
            var tremble2=0 //idem pour Main_enigme
            var current; //objet en cours de selection
            var freeze=false // permet de bloquer le clavier;           
            var rotation=0; //variable controlant la rotation de la camera 0,90,-90,180
            var pos_l,pos_c //la position de la caméra dans le tableau laby
            var eng,controleur,inv //les canvas pour l'énigme, le dialogue et l'inventaire
            var Main_control //le container de base du controler (nécessaire pour redimensionner)
            var Main_enigme //le container de base de l'énigme (nécessaire pour redimensionner)
            var Main_inventaire //idem pour l'inventaire
            var phara //container du pharaon
            var objets // l'inventaire
            var big_enigme; //liste des enigmes sur canvas
            var small_enigme=[]
            var liste_stel=[]; //liste des steles;
            var liste_mom=[]; //listes des momies;
            var liste_objets=[]; //listes des objets;                     
            var mode="laby" //ou "enigme" si le joueur est en train de résoudre une énigme.
            var premier_objet=true;
            var premier_enigme=true;
            var all_objet=false;
            var first_perte=true;

            var sauvegarde={
                "laby":null, //le tableau du labyrinthe
                "inventaire":null, //le tableau contenant l'inventaire
                "utilise":null, //le tableau contenant les objets utilisés
                "e1":null, //la config de l'énigme 1
                "e2":null,
                "e3":null,
                "e4":null,
                "e5":null,
                "position":null //position du joueur/camera

            }
            
           
        
            var dim1=25
            var dim2=25
            var Laby           
            //On complète le laby
            let is_complete=false;
            while (is_complete==false){
                Laby=creer_laby(dim1,dim2);
                Laby[2][1]=2;
                let c1=complete_laby_stele(1,1,Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));               
                let c2=complete_laby_stele(1,Math.floor((dim2-2)/2),Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));              
                let c3=complete_laby_stele(Math.floor((dim1-2)/2),1,Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));                             
                let c4=complete_laby_stele(Math.floor((dim1-2)/2),Math.floor((dim2-2)/2),Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));               
                let c5=complete_laby_stele(1,1,dim1-2,dim2-2);               
                is_complete=true && c1 && c2 && c3 && c4  &&  c5;
                c1=complete_laby_objet(3,3,Math.floor((dim1-2)/2)-2,Math.floor((dim2-2)/2)-2);               
                c2=complete_laby_objet(3,Math.floor((dim2-2)/2),Math.floor((dim1-2)/2)-2,Math.floor((dim2-2)/2));              
                c3=complete_laby_objet(Math.floor((dim1-2)/2),1,Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));                             
                c4=complete_laby_objet(Math.floor((dim1-2)/2),Math.floor((dim2-2)/2),Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));               
                c5=complete_laby_objet(3,3,dim1-4,dim2-4);               
                is_complete=is_complete && c1 && c2 && c3 && c4  &&  c5;
                c1=complete_laby_monstre(3,3,Math.floor((dim1-2)/2)-2,Math.floor((dim2-2)/2)-2);               
                c2=complete_laby_monstre(3,Math.floor((dim2-2)/2)-2,Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));              
                c3=complete_laby_monstre(Math.floor((dim1-2)/2),1,Math.floor((dim1-2)/2),Math.floor((dim2-2)/2));                             
                c4=complete_laby_monstre(Math.floor((dim1-2)/2),Math.floor((dim2-2)/2),Math.floor((dim1-2)/2),Math.floor((dim2-2)/2)); 
                is_complete=is_complete && c1 && c2 && c3 && c4  ;
                c1=trou(3,3,dim1-4,dim2-4);    
                c2=trou(3,3,dim1-4,dim2-4);    
                c3=trou(3,3,dim1-4,dim2-4); 
                is_complete=is_complete && c1 && c2 && c3  

            }
            Laby[0][1]=6;

           

            //debug_laby();


        function trou(l,c,largeur,hauteur){
            let res=false;
            let count=0;
            let ligne,colonne
            while(res==false && count<100000){
                //on place une stèle                
                ligne=l+Math.floor((hauteur)*Math.random());
                colonne=c+Math.floor((largeur)*Math.random());                            
                if(Laby[ligne][colonne]==1){
                    res=true;
                }
                count++;                      
            }
            if(count<100000){                
                Laby[ligne][colonne]=0
            }
            return(res)

        } 
            
        function culdesac(l,c){
            if(Laby[l+1][c]==0 && Laby[l-1][c]==1 && Laby[l][c+1]==1 && Laby[l][c-1]==1){return true}
            if(Laby[l+1][c]==1 && Laby[l-1][c]==0 && Laby[l][c+1]==1 && Laby[l][c-1]==1){return true}
            if(Laby[l+1][c]==1 && Laby[l-1][c]==1 && Laby[l][c+1]==0 && Laby[l][c-1]==1){return true}
            if(Laby[l+1][c]==1 && Laby[l-1][c]==1 && Laby[l][c+1]==1 && Laby[l][c-1]==0){return true}
            return(false)
        }  

        function free_next(l,c){
            if(Laby[l+1][c]==0){return [l+1,c]}
            if(Laby[l][c+1]==0){return [l,c+1]}
            if(Laby[l-1][c]==0){return [l-1,c]}
            if(Laby[l][c-1]==0){return [l,c-1]}           
            
        }
            
        function complete_laby_stele(l,c,largeur,hauteur){           
            let res=false;
            let count=0;
            let ligne,colonne
            while(res==false && count<100000){
                //on place une stèle                
                ligne=l+Math.floor((hauteur)*Math.random());
                colonne=c+Math.floor((largeur)*Math.random());                                         
                if(Laby[ligne][colonne]==0){
                    res=culdesac(ligne,colonne)
                }
                count++;                      
            }
            if(count<100000){                
                Laby[ligne][colonne]=4
            }
            return(res)
        }

        function complete_laby_objet(l,c,largeur,hauteur){           
            let res=false;
            let count=0;
            let ligne,colonne
            while(res==false && count<100000){
                //on place une stèle                
                ligne=l+Math.floor((hauteur)*Math.random());
                colonne=c+Math.floor((largeur)*Math.random());                            
                if(Laby[ligne][colonne]==0){
                    res=true;
                }
                count++;                      
            }
            if(count<100000){                
                Laby[ligne][colonne]=5
            }
            return(res)
        }

         function complete_laby_monstre(l,c,largeur,hauteur){           
            let res=false;
            let count=0;
            let ligne,colonne
            while(res==false && count<100000){
                //on place une stèle                
                ligne=l+Math.floor((hauteur)*Math.random());
                colonne=c+Math.floor((largeur)*Math.random());                            
                if(Laby[ligne][colonne]==0){
                    res=true;
                }
                count++;                      
            }
            if(count<100000){                
                Laby[ligne][colonne]=3
            }
            return(res)
        }

            
        function init() {

             eng = document.getElementById("eng"); 
             stage_enigme = new createjs.Stage(eng);
             createjs.Ticker.addEventListener("tick", stage_enigme); // pour que la scene1 soit redessinée à chaque "tick"

             Ch=new Chargement();
             Ch.x=400
             Ch.y=150
             stage_enigme.addChild(Ch)

	       
	       images = images||{};
           textures =textures ||{}

	       var manifest = [
		     
              {src:"images/mur.jpg", id:"mur"},
              {src:"images/mur2.jpg", id:"mur2"},
              {src:"images/mur3.jpg", id:"mur3"},
              {src:"images/sand.jpg", id:"sand"},
              {src:"images/momie.png", id:"momie"},
              {src:"images/compagnon.png", id:"compagnon"},
              {src:"images/cuir.png", id:"cuir"},
              {src:"images/serpent.png", id:"serpent"},
              {src:"images/pierre.jpg", id:"pierre"},
              {src:"images/gemme_bleu.png", id:"gemme_bleu"},
              {src:"images/gemme_rouge.png", id:"gemme_rouge"},
              {src:"images/gemme_verte.png", id:"gemme_verte"},
              {src:"images/gemme_jaune.png", id:"gemme_jaune"},
              {src:"images/gemme_blanche.png", id:"gemme_blanche"},
              {src:"images/stele.png", id:"stele"},
              {src:"images/scarabe.png", id:"scarabe"},
              {src: "images/empreinte_f.png", id:"empreinte_f"},
              {src: "images/empreinte_p.png", id:"empreinte_p"},
              {src: "images/galet.png", id:"galet"},
              {src: "images/papyrus.png", id:"papyrus"},
              {src: "images/papyrus2.png", id:"papyrus2"},
              {src: "images/sablier.png", id:"sablier"},
              {src: "images/urne.png", id:"urne"},
              {src: "images/piece3d.png", id:"piece3d"},
              {src: "images/background.jpg", id:"background"},
              {src: "images/indy.png", id:"indy"},
              {src: "images/pyramide.png", id:"pyramide"},

             
               
	       ];

	       var loader = new createjs.LoadQueue(false);
           loader.addEventListener("fileload", handleFileLoad);
	       loader.addEventListener("complete", handleComplete);
           loader.addEventListener("progress", handleProgress);
	       loader.loadManifest(manifest);
            }

            function handleProgress(evt){  
            Ch.Pourcentage.text="Chargement "+Math.floor(evt.progress*100)+" %"
        }



        function handleFileLoad(evt) {
            if (evt.item.type == "image") { images[evt.item.id] = evt.result;
            let t=new THREE.Texture(evt.result );
            t.needsUpdate=true;
            textures[evt.item.id] = t }
            

        }            
        
        /////////////////////////////////////////////////////////// creation des stages //////////////////////////////////
        function handleComplete() {
            Ch.Clear();
            // Création de la scène 3D
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog("#000000", 0.0025, 5);
            var L=window.innerWidth*2/3
            Main_Scale=L/755
            
            camera = new THREE.PerspectiveCamera( 40, 755 / 400, 0.1, 1000 );
            renderer = new THREE.WebGLRenderer();
            
            renderer.setSize( L, 400*Main_Scale );
            renderer.domElement.style.display="none"
            document.body.appendChild( renderer.domElement );     
                
            camera.position.z = 0.5;
            camera.position.y = 0.5;           
            camera.position.x = 0;
        
            camera.lookAt(new THREE.Vector3( 0, 0.5, -1 ))
            
            ////////////////////////////// CONTROL ORBITAL ////////////////////////
           /*  var controls = new THREE.OrbitControls( camera );  
            var light = new THREE.AmbientLight( 0xFFFFFF ); 
            scene.add( light );  
            scene.fog=null        
            controls.update(); */
            //////////////////////////////////////////////////////////////////
            
            // placement du personnage
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==2){                    
                    camera.position.x=-dim1/2+1*j;
                    camera.position.z=-dim2/2+1*i+0.5;  
                    pos_l=i;
                    pos_c=j;
                    Laby[i][j]=0;
                    break;
                        }
                        }
                    }
            
            var light = new THREE.AmbientLight( 0x000020 ); 
            scene.add( light );
            
            spotLight = new THREE.PointLight(  0xFFFFFF,  1.5,  40,  20 ,0.5,0.5,2);
            spotLight.position.set( camera.position.x,  camera.position.y,  camera.position.z );
            scene.add( spotLight );
            
            pyramide=new THREE.Object3D();            
            scene.add(pyramide);
            render();
            ////////////////////////////////////////////////// CREATION DES ENIGMES //////////////////////////////////////////  
            big_enigme=[puzzle_1(),puzzle_2(),puzzle_3(),puzzle_4(),puzzle_5()]; //liste des enigmes sur canvas
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
            let cont=document.getElementById("enigme")
            eng = document.getElementById("eng");  
            inv = document.getElementById("inv");  
            controleur=document.getElementById("controleur");
            eng.width=renderer.domElement.width;
            eng.height=renderer.domElement.height;
            
            
            cont.style.left=window.innerWidth/6+"px";
            cont.style.top=(window.innerHeight-400*Main_Scale)/3+"px";
            controleur.width=renderer.domElement.width;
            controleur.height=renderer.domElement.height;
            controleur.style.left=window.innerWidth/6+"px";
            controleur.style.top=(window.innerHeight-400*Main_Scale)/3+"px";
            renderer.domElement.style.left=window.innerWidth/6+"px";
            renderer.domElement.style.top=(window.innerHeight-400*Main_Scale)/3+"px";
            
            inv.width=renderer.domElement.width;
            inv.style.left=window.innerWidth/6+"px";
            
            inv.style.top=(parseInt(controleur.style.top)+parseInt(controleur.height)+10)+"px";
            
            
                
            stage_controleur = new createjs.Stage(controleur);
            stage_inventaire = new createjs.Stage(inv);
            createjs.Ticker.timingMode = createjs.Ticker.RAF; // pour une animation Tween plus fluide             
            createjs.Ticker.addEventListener("tick", stage_controleur); // pour que la scene2 soit redessinée à chaque "tick"
            createjs.Ticker.addEventListener("tick", stage_inventaire); // pour que la scene3 soit redessinée à chaque "tick"
            createjs.Ticker.addEventListener("tick", createjs.Tween); // pour que Tween fonctionne après un Ticker.reset() au déchargement de l'exercice;
            createjs.Touch.enable(stage_enigme); 
            createjs.Touch.enable(stage_inventaire); 
            stage_enigme.enableMouseOver(); 
            stage_inventaire.enableMouseOver();
            stage_controleur.enableMouseOver(); 
            createjs.Touch.enable(stage_controleur); 
                            
            
            Main_control=new createjs.Container();
            stage_controleur.addChild(Main_control);
            let htmlElement=document.getElementById('reponse')
            let ch=new createjs.DOMElement(htmlElement); 
            ch.x=550;
            ch.y=300;
            Main_control.addChild(ch);
            Main_control.scaleX=Main_control.scaleY=Main_Scale;

            Main_enigme=new createjs.Container();
            stage_enigme.addChild(Main_enigme)
            Main_enigme.scaleX=Main_enigme.scaleY=Main_Scale;            

            Main_inventaire=new createjs.Container();
            stage_inventaire.addChild(Main_inventaire);
            Main_inventaire.scaleX=Main_inventaire.scaleY=Main_Scale;
            
            ////////////////////////////////////////////////////////////// PAGE TITRE ///////////////////////////////////////
            let etape_begin=page_titre();
            Main_enigme.addChild(etape_begin)
            eng.style.zIndex=4000;
            freeze=true;
            etape_begin.addEventListener("enroute",()=>{
                renderer.domElement.style.display=""
                createjs.Tween.get(etape_begin).to({x:1000},500).call(()=>{Main_enigme.removeChild(etape_begin);eng.style.zIndex=1000;mode="laby"; });
                createjs.Tween.get(phara).wait(1200).to({x:750},500).call(()=>{freeze=true;intro()});
            })


            ////////////////////////// création et gestion de l'inventaire ////////////////////////////
            objets=inventaire();
            Main_inventaire.addChild(objets);
            objets.addEventListener("prendre",prise);
            objets.addEventListener("deposer",depose);
            objets.addEventListener("utiliser",utilise);

            function get_objet(L,C){
                for(let i=0;i<liste_objets.length;i++){
                    if(liste_objets[i].L==L && liste_objets[i].C==C){
                        return(liste_objets[i])
                    }
                }
            }

            function utilise(){
                let o=objets.selected; 
                if(mode=="porte"){ 
                    console.log(objets.selected)
                    if(o.objet.info.indice==1000000){
                       objets.deranger();
                       console.log(o.couleur)
                       switch(o.objet.couleur){
                           case "gemme_rouge":
                           emplacement.rouge.visible=true;
                           break;
                           case "gemme_bleu":
                           emplacement.bleu.visible=true;
                           break;
                           case "gemme_verte":
                           emplacement.vert.visible=true;
                           break;
                           case "gemme_jaune":
                           emplacement.jaune.visible=true;
                           break;
                           case "gemme_blanche":
                           emplacement.blanche.visible=true;
                           break;
                       }
                       if(emplacement.rouge.visible==true && emplacement.bleu.visible==true && emplacement.vert.visible==true && emplacement.jaune.visible==true && emplacement.blanche.visible==true){
                        sortie.open();
                       }
                      
                       stage_texture.update();
                       sortie.material.map.needsUpdate=true;


                    }
                } else {             
                    let enface_l=enface().l;
                    let enface_c=enface().c  ;                
                    let e=get_stele(enface_l,enface_c).enigme;                                         
                    console.log(e.indice)
                    console.log(o.objet.info.indice)           
                    if(e.indice==o.objet.info.indice){                    
                        objets.deranger();
                        e.debloque();
                    } else {
                        console.log("mauvais objet");
                        tremble2=10;
                        temps=temps-60;
                    }
                }
                
            }

            function prise(e){  
                if(mode=="enigme"){mode="laby"}                          
                let enface_l=enface().l;
                let enface_c=enface().c ;              
                let o=get_objet(enface_l,enface_c);                
                o.prise(enface_l,enface_c);
                objets.ranger(o);
            }

            function depose(e){               
                let enface_l=enface().l;
                let enface_c=enface().c;
                
                if(Laby[enface_l][enface_c]==0){
                    let o=objets.deranger();
                    o.replace(enface_l,enface_c);
                    objets.prendre.alpha=1;
                }               
                
            }
            ////////////////////////////////////////////////////////////////////////////////////////    
                
          
                
            /////////////////////// Dialogues /////////////////////////            
            phara=new createjs.Bitmap(images["indy"]);
            phara.scaleX=-0.3
            phara.scaleY=0.3
            //phara.x=650 x final
            phara.x=1000;
            phara.y=250 // y final          
            Main_control.addChild(phara);
           
            
            
            //////////////////////// Création des objets ///////////////////////////
            let o1=[textures["serpent"],textures["scarabe"],textures["papyrus2"],textures["urne"],textures["piece3d"]]
            let o2=[images["serpent"],images["scarabe"],images["papyrus2"],images["urne"],images["piece3d"]]
            let o3=[0,1,2,3,4]
            let o4=[0.08,0.11,0.09,0.06,0.09]
            //let o4=[0.08,0.11,0.09,0.08] [serpent,scarabe,parpyrus2,urne]
                       
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==5){
                    let alea=Math.floor(o1.length*Math.random());
                    alea=0;
                    let t=o1[alea];
                    var objMaterial = new THREE.SpriteMaterial( { map: t, color: 0xffffff } );                
                    objMaterial.fog=true;
                    let c=Objet(1,3,1,objMaterial);
                    c.position.x=-dim1/2+1*j;
                    c.position.z=-dim2/2+1*i+0.5;
                    c.position.y=0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.2;
                    c.L=i;
                    c.C=j;      
                    pyramide.add(c); 
                    c.info={indice:o3[alea],bitmap:new createjs.Bitmap(o2[alea]),scale:o4[alea]}; //indice: l'indice dans big_enigme de l'énigme correspondant à cet objet, bitmap pour l'image de l'inventaire, scale pour le dimensionner dans l'inventaire
                    o1.splice(alea,1);
                    o2.splice(alea,1);
                    o3.splice(alea,1);
                    o4.splice(alea,1);
                    liste_objets.push(c);
                        }
                    }
                } 
            // LES OBJETS
            function Objet(l,L,h,material){  
                var sprite = new THREE.Sprite( material );    
                
                sprite.prise=function(l,d){   
                    freeze=true; 
                    Laby[l][d]=0;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }    
                
                sprite.replace=function(l,d){ 
                    freeze=true;   
                    Laby[l][d]=5;
                    sprite.position.x=-dim1/2+1*d;
                    sprite.position.z=-dim2/2+1*l+0.5;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    sprite.L=l;
                    sprite.C=d;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:0.35}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }  
                return(sprite);                           
            } 
            
            
            
            //////////////////////// Création des gemmes ///////////////////////////
            let gemmes=["gemme_bleu","gemme_rouge","gemme_verte","gemme_jaune","gemme_blanche"]        
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==4){
                    var t=textures[gemmes[0]];                   
                    var gMaterial = new THREE.SpriteMaterial( { map: t, color: 0xffffff } );                
                    gMaterial.fog=true;
                    let c=Gemme(1,3,1,gMaterial);
                    c.position.x=-dim1/2+1*j;
                    c.position.z=-dim2/2+1*i+0.5;
                    c.position.y=-0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.2;
                    c.L=i;
                    c.C=j;      
                    pyramide.add(c); 
                    c.couleur=gemmes[0];
                    c.info={indice:1000000,bitmap:new createjs.Bitmap(images[gemmes[0]]),scale:0.08}; //indice: l'indice dans big_enigme de l'énigme correspondant à cet objet, bitmap pour l'image de l'inventaire, scale pour le dimensionner dans l'inventaire
                    liste_objets.push(c);
                    gemmes.splice(0,1);
                    ///////////////pour tester la sortie////////////////////
                    //c.prise(i,j);
                    //objets.ranger(c)

                        }
                    }
                } 
            function Gemme(l,L,h,material){  
                var sprite = new THREE.Sprite( material );    
                
                sprite.prise=function(l,d){  
                    freeze=true; 
                    Laby[l][d]=0;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }    

                sprite.appear=function(){
                    freeze=true; 
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:0.35}, 2000 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;                                        
                                            sprite.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                            sprite.position.z=c+0.05*Math.cos(Math.random()*6.28);
                                            let enface_l=enface().l;
                                            let enface_c=enface().c;    
                                            Laby[enface_l][enface_c]=5;                                           
                                        })
                                        
                                        .onComplete( ()=>{
                                            freeze=false;
                                            objets.prendre.alpha=1;


                                        })
                                    .delay(1000)
                                    .start();

                }
                
                sprite.replace=function(l,d){ 
                    freeze=true;   
                    Laby[l][d]=5;
                    sprite.position.x=-dim1/2+1*d;
                    sprite.position.z=-dim2/2+1*l+0.5;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    sprite.L=l;
                    sprite.C=d;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:0.35}, 500 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;
                                            sprite.position.x=a
                                            sprite.position.z=c                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }  
                return(sprite);                           
            }
        
            //////////////////////// Création des stèles ///////////////////////////            
            var steleMaterial = new THREE.SpriteMaterial( { map: textures["stele"], color: 0xffffff } );
            steleMaterial.fog=true;
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==4){
                    let c=Stele(1,3,1,steleMaterial);
                    c.position.x=-dim1/2+1*j;
                    c.position.z=-dim2/2+1*i+0.5;
                    c.position.y=0.35;
                    c.scale.x=c.scale.y=c.scale.z=0.7;
                    c.L=i;
                    c.C=j;
                    c.enigme=big_enigme[0];
                    liste_stel.push(c);
                    pyramide.add( c ); 
                    big_enigme.splice(0,1)
                    }
                    }
                }   
            function Stele(l,L,h,material){  
                var sprite = new THREE.Sprite( material );   
                
                sprite.disappear=function(){
                    freeze=true; 
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 3000 )
                                        .onUpdate( function () {                               
                                            sprite.position.y = this.y;                                        
                                            sprite.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                            sprite.position.z=c+0.05*Math.cos(Math.random()*6.28)                                      
                                        } )
                                        
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();

                }
                
                return(sprite);                           
            }            
        
        
            ///////////////////////// Création des monstres //////////////////////////////////////////////
            small_enigme=[];
            small_enigme.push([q1,"1678"]);
            small_enigme.push([q2,"12"]);
            small_enigme.push([q1,"1678"]);
            small_enigme.push([q1,"1678"]);
          
            let monstre=["momie","momie","momie","momie"]           
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                        if(Laby[i][j]==3){
                        var momieMaterial = new THREE.SpriteMaterial( { map: textures[monstre[0]], color: 0xffffff } );
                        momieMaterial.fog=true;
                        let c=Momie(1,3,1,momieMaterial);
                        c.position.x=-dim1/2+1*j;
                        c.position.z=-dim2/2+1*i+0.5;
                        c.position.y=0.35;
                        c.scale.x=c.scale.y=c.scale.z=0.7
                        c.L=i;
                        c.C=j;
                        c.enigme=small_enigme[0];
                        liste_mom.push(c)
                        pyramide.add( c ); 
                        small_enigme.splice(0,1);
                        monstre.splice(0,1);
                        }
                    }
                }

            function Momie(l,L,h,material){ 
                var sprite = new THREE.Sprite( material ); 
                sprite.clear=function(b,l,d){
                    b.clear();
                    freeze=true;
                    document.getElementById("contenu").value="";
                    Laby[l][d]=0;
                    let a=sprite.position.x;
                    let c=sprite.position.z;
                    let twe=new TWEEN.Tween( { y:sprite.position.y } )
                                        .to( { y:-1}, 2500 )
                                        .onUpdate( function () {                               
                                        sprite.position.y = this.y;
                                        sprite.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                        sprite.position.z=c+0.05*Math.cos(Math.random()*6.28)                                       
                                        } )
                                        .onComplete( ()=>{freeze=false}
                                            )
                                    .start();
                }          
                return(sprite);                          
            }
            
                        
            ///////////////////////// Création du sol/////////////////////////////////////////////////////////////////////////////
            let solTexture=textures["sand"];
            solTexture.wrapS = THREE.RepeatWrapping;
            solTexture.wrapT = THREE.RepeatWrapping;
            //solTexture.repeat.set( 20, 20 );
            solTexture.repeat.set( dim1, dim2 );
            var solMaterial = new THREE.MeshPhongMaterial( { map: solTexture, color: 0xffffff } );
            //let ground=Sol(20,0.01,20,solMaterial);
            let ground=Sol(dim1,0.01,dim2,solMaterial);
            pyramide.add( ground );    
            function Sol(l,L,h,material_sol){ 
                var geometry = new THREE.BoxGeometry( l,L,h );                
                this.cube = new THREE.Mesh( geometry, material_sol );                  
                return(this.cube);                        
            }      

            ///////////////////////// Création de la porte de sortie //////////////////////////////////////
            canvas_texture=document.getElementById("texture_maker");
            stage_texture=new createjs.Stage(canvas_texture);
            porte=new createjs.Bitmap(images["mur"]);
            stage_texture.addChild(porte);
            slot = function() {
                let res=new createjs.Container();                
                res.vert = new createjs.Bitmap(images["gemme_verte"]);
                res.vert.setTransform(72.6,82,0.17,0.17,38.1);
                res.rouge =  new createjs.Bitmap(images["gemme_rouge"]);
                res.rouge.setTransform(409.6,83.1,0.17,0.17,38.1);
                res.jaune =  new createjs.Bitmap(images["gemme_jaune"]);
                res.jaune.setTransform(72.6,262.5,0.17,0.17,38.1);
                res.bleu=  new createjs.Bitmap(images["gemme_bleu"]);
                res.bleu.setTransform(412.6,261.5,0.17,0.17,38.1);
                res.blanche =  new createjs.Bitmap(images["gemme_blanche"]);
                res.blanche.setTransform(247.6,169,0.17,0.17,38.1); 
                res.vert.visible=res.bleu.visible=res.jaune.visible=res.blanche.visible=res.rouge.visible=false;              
                let shape = new createjs.Shape();               
                shape.graphics.f().s("#993300").ss(0.1,1,1).p("AVmn5IJckbIAAjIIhViCIjNiCIkiAoIgrKWAV/T0IJckbIAAjIIhViCIjNiCIkiAoIgrKWAjnFXIJakbIAAjGIhViCIjNiCIkgAoIgrKUA/DoRIJckbIAAjIIhViCIjNiCIkiAoIgrKXA/HT5IJckbIAAjIIhViCIjNiCIkiAoIgrKW");
                shape.setTransform(258,230.3);

                let shape_1 = new createjs.Shape();
                shape_1.graphics.f("#993300").s().p("A/aTQIArqWIEigoIDNCCIBVCCIAADIIpcEbgAVsTLIArqWIEigoIDNCCIBVCCIAADIIpcEbgAj6EuIArqUIEggoIDNCCIBVCCIAADGIpaEbgAVToiIArqWIEigoIDNCCIBVCCIAADIIpcEbgA/Wo5IArqXIEigoIDNCCIBVCCIAADIIpcEbg");
                shape_1.setTransform(258,230.3);

                let shape_2 = new createjs.Shape();
                shape_2.graphics.f().s("#CC9933").ss(30.4,1,1).p("AYyOCQqRF1uhAAQugAAqSl1QqRl0AAoOQAAoNKRl0QKSl1OgAAQOhAAKRF1QKSF0AAINQAAIOqSF0g");
                shape_2.setTransform(255,233.5);
                res.addChild(shape_2,shape_1,  shape, res.blanche,res.bleu,res.jaune,res.vert,res.rouge);
                return(res)
            }
            emplacement=slot();
            emplacement.scaleX=emplacement.scaleY=0.25;            
            emplacement.y=450;
            emplacement.x=194;
            stage_texture.addChild(emplacement);
            stage_texture.update();

            var porteMaterial = new THREE.MeshPhongMaterial( { map: new THREE.CanvasTexture(canvas_texture), color:0xFFFFFF,specular: 0x000000, shininess: 10 } ); //new THREE.CanvasTexture(canvas_texture); 
                       
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==6){
                        sortie=Cube(1,3,1,porteMaterial);
                        sortie.position.x=-dim1/2+1*j;
                        sortie.position.z=-dim2/2+1*i+0.5;
                        sortie.position.y=-1.5;
                        pyramide.add( sortie);                        
                            }
                    }
            }


            
            ///////////////////////// Création des murs et bordures /////////////////////////////////////////////////////////////////////////////
            var murMaterial1 = new THREE.MeshPhongMaterial( { map: textures["mur"], color:0xFFFFFF,specular: 0x000000, shininess: 10 } ); 
            var murMaterial2 = new THREE.MeshPhongMaterial( { map: textures["mur2"], color:0xFFFFFF,specular: 0x000000, shininess: 10 } ); 
            var murMaterial3 = new THREE.MeshPhongMaterial( { map: textures["mur3"], color:0xFFFFFF,specular: 0x000000, shininess: 10 } );  
            var bordMaterial = new THREE.MeshLambertMaterial( { color:0xFF6600} )          
            let count=0;
            for(let i=0;i<Laby.length;i++){
                for(let j=0;j<Laby.length;j++){
                    if(Laby[i][j]==1){
                    count++;
                    let c;
                    if(count%2==0){
                        c=Cube(1,3,1,murMaterial1);
                    } else {
                        let r=Math.random();
                        if(r<0.25){
                        c=Cube(1,3,1,murMaterial2);}
                        if(r>0.75){
                        c=Cube(1,3,1,murMaterial3);   
                        }
                        if(r<=0.75 && r>=0.25){
                        c=Cube(1,3,1,murMaterial1);   
                        }
                    }
                    //c.position.x=-10+1*j;
                    //c.position.z=-10+1*i+0.5;
                    c.position.x=-dim1/2+1*j;
                    c.position.z=-dim2/2+1*i+0.5;
                    c.position.y=0.5;
                    pyramide.add( c ); 
                    let  b=Bord(0.5,0.2,0.05,0.05,bordMaterial)                    
                    //b.position.x=-10+1*j;
                    //b.position.z=-10+1*i;
                    b.position.x=-dim1/2+1*j;
                    b.position.z=-dim2/2+1*i;
                    b.position.y=0;
                    pyramide.add( b );
                    }
                    }
                }
            function Cube(l,L,h,material_mur){  
                var geometry = new THREE.BoxGeometry( l,L,h );               
                let cube = new THREE.Mesh( geometry, material_mur );          
                cube.open=function(){                   
                        //freeze=true;                   
                        Laby[0][1]=0;
                        let a=cube.position.x;
                        let c=cube.position.z;
                        let twe=new TWEEN.Tween( { y:cube.position.y } )
                                            .to( { y:-1.5}, 3500 )
                                            .onUpdate( function () {                               
                                            cube.position.y = this.y;
                                            cube.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                            cube.position.z=c+0.05*Math.cos(Math.random()*6.28)                                       
                                            } )
                                            .onComplete( ()=>{freeze=false; Laby[0][1]=0;}
                                                )
                                        .start();
                    }
                cube.close=function(){                   
                        //freeze=true;                   
                        Laby[0][1]=0;
                        let a=cube.position.x;
                        let c=cube.position.z;
                        let twe=new TWEEN.Tween( { y:cube.position.y } )
                                            .to( { y:0.5}, 3500 )
                                            .onUpdate( function () {                               
                                            cube.position.y = this.y;
                                            cube.position.x=a+0.05*Math.cos(Math.random()*6.28);
                                            cube.position.z=c+0.05*Math.cos(Math.random()*6.28)                                       
                                            } )
                                            .onComplete( ()=>{freeze=false; Laby[0][1]=6;}
                                                )
                                        .start();
                    }                         
                return(cube);          
                }
            function Bord(l,L,h,e,material){        
            var shape = new THREE.Shape();
                shape.moveTo( -l,h );
                shape.lineTo( l, h );
                shape.lineTo( l+e, 0 );
                shape.lineTo( -l-e, 0 );
                shape.lineTo( -l, h );
                var extrudeSettings = {
                    steps: 2,
                    amount: 1,                   
                    bevelEnabled: true,
                    bevelThickness: e,
                    bevelSize: e                   
                };
                var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );                              
                this.cube = new THREE.Mesh( geometry, material );                
                return(this.cube);                 
            } 
            //////////////////////////////////////////////////////////////////////////////////////////////
        
                
    
                
            
            
        }
                            
         
            

        function get_stele(L,C){                         
            for(let i=0;i<liste_stel.length;i++){
                if(liste_stel[i].L==L && liste_stel[i].C==C){
                    return(liste_stel[i])
                }
            }
        }

        function get_momie(L,C){                         
            for(let i=0;i<liste_mom.length;i++){
                if(liste_mom[i].L==L && liste_mom[i].C==C){
                    return(liste_mom[i])
                }
            }
        }

        function get_objet(L,C){                         
            for(let i=0;i<liste_objets.length;i++){
                if(liste_objets[i].L==L && liste_objets[i].C==C){
                    return(liste_objets[i])
                }
            }
        }

        function detect_objet(dir){
            let obstacle=false  ;
            if(pos_l-1<0){return false}            
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]==5){obstacle=true};break;
                case -90: if(Laby[pos_l][pos_c+1]==5){obstacle=true};break;
                case 90: if(Laby[pos_l][pos_c-1]==5){obstacle=true};break;
                case 180: if(Laby[pos_l+1][pos_c]==5){obstacle=true};break;
            }               
            return(obstacle);
        }

         function detect_porte(dir){
            let obstacle=false    ;
            if(pos_l-1<0){return false}            
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]==6){obstacle=true};break;
                case -90: if(Laby[pos_l][pos_c+1]==6){obstacle=true};break;
                case 90: if(Laby[pos_l][pos_c-1]==6){obstacle=true};break;
                case 180: if(Laby[pos_l+1][pos_c]==6){obstacle=true};break;
            }               
            return(obstacle);
        }
        

        function intro(){
            let b=dialogue(introduction,"qcm",["J'ai compris."],["#fc00ed"],["suite"]);
            b.x=640;
            b.y=330;            
            b.addEventListener("suite",()=>{
                document.onkeydown=keyPressed;            
                 document.onkeyup=multiple_key;
                 freeze=false;b.clear();createjs.Tween.get(phara).wait(300).to({x:1000},500);montre=setInterval('chrono()',1000) })
            Main_control.addChild(b)
            sortie.close();
        }

        function chrono(){
            if(temps==0){
                temps=0;
                clearInterval(montre);
                document.getElementById("chr").innerHTML="Temps: "+0+"min "+0+"s";               
                console.log("perdu !");
                let fin_bad=page_fin();
                Main_enigme.addChild(fin_bad);
                eng.style.zIndex=4000;
                freeze=true;
                setTimeout(fin_bad.cfini,2000)


            } else {
            temps-=1;
            let min=Math.floor(temps/60);
            let sec=temps%60;
            document.getElementById("chr").innerHTML="Temps: "+min+"min "+sec+"s";
            }
        }

        function first_objet(){            
            premier_objet=false;
            mode="enigme"
            freeze=true;            
            let b=dialogue(premiere_fois,"qcm",["J'ai compris."],["#fc00ed"],["suite"]);
            b.x=640;
            b.y=330;            
            b.addEventListener("suite",()=>{b.clear();objets.prendre.alpha=1;createjs.Tween.get(phara).wait(300).to({x:1000},500);})
            Main_control.addChild(b)
        }

        function trouve_stele(){ 
            let m;
            if(premier_enigme==true){m=meca2;premier_enigme=false}else{m=meca}           
            let b=dialogue(m,"qcm",["OUI","NON"],["#fc00ed","#fc00ed"],["oui","non"]);
            b.x=640;
            b.y=330;   
            Main_control.addChild(b)         
            b.addEventListener("non",()=>{b.clear();createjs.Tween.get(phara).wait(300).to({x:1000},500);By_pass();mode="laby"})
            b.addEventListener("oui",()=>{  b.clear();
                                            mode="enigme";
                                            let enface_l=enface().l;
                                            let enface_c=enface().c;                                           
                                            createjs.Tween.get(phara).wait(300).to({x:1000},500);
                                            let e=get_stele(enface_l,enface_c).enigme;    
                                            e.x=-1000;  
                                            e.quitter.visible=false;                                                                        
                                            Main_enigme.addChild(e);                                               
                                            createjs.Tween.get(e).to({x:0},500)
                                            eng.style.zIndex=4000; 
                                            e.addEventListener("quitter",()=>{ 
                                                objets.reset(); 
                                                e.removeAllEventListeners()             
                                                createjs.Tween.get(e).to({x:1000},500).call(()=>{Main_enigme.removeChild(e);eng.style.zIndex=1000;By_pass();mode="laby" })
                                            })
                                            e.addEventListener("valider",()=>{
                                                if(e.evaluer()=="juste"){
                                                objets.reset();  
                                                e.removeAllEventListeners()             
                                                createjs.Tween.get(e).to({x:1000},500).call(()=>{
                                                    Main_enigme.removeChild(e);
                                                    eng.style.zIndex=1000;By_pass();
                                                    get_stele(enface_l,enface_c).disappear();
                                                    get_objet(enface_l,enface_c).appear();
                                                    mode="laby";
                                                    })  
                                                } else {
                                                    tremble2=10;
                                                    temps=temps-60;
                                                }
                                            })
                                            if(e.bloque==true){  
                                                objets.bloque=true;
                                                eng.style.zIndex=1000; 
                                                createjs.Tween.get(phara,{override:true}).to({x:750},500).call(()=>{                                                    
                                                    let b2=dialogue(need_objet,"qcm",["OK"],["#fc00ed"],["ok"]);
                                                    b2.x=640;
                                                    b2.y=330;   
                                                    Main_control.addChild(b2)    
                                                    b2.addEventListener("ok",()=>{b2.clear();createjs.Tween.get(phara).wait(300).to({x:1000},500);eng.style.zIndex=4000;objets.bloque=false; e.quitter.visible=true;})
                                                    }
                                                )
                                            } else { e.quitter.visible=true;}
                            })
        }         
            
        var tw //la tween de déplacement

        function By_pass(){
            let enface_l=enface().l;
            let enface_c=enface().c           
            if(Laby[enface_l][enface_c]==0){
                freeze=true;
                let f1=camera.position.z
                let f2=camera.position.x                            

                if(rotation==0){                            
                    f1=camera.position.z-1;
                    pos_l--;
                    }
                if(rotation==180){                            
                    f1=camera.position.z+1;
                    pos_l++;
                                }
                if(rotation==90){                            
                    f2=camera.position.x-1; 
                    pos_c--;
                }
                if(rotation==-90){                            
                    f2=camera.position.x+1;  
                    pos_c++;
                }      

                tw=new TWEEN.Tween( { z:camera.position.z,x:camera.position.x  } )
                        .to( { z:f1,x:f2 }, 250 )
                        .onUpdate( function () {                               
                        camera.position.z = this.z;
                        spotLight.position.z=this.z;
                        camera.position.x = this.x;
                        spotLight.position.x=this.x;
                        } )
                        .onComplete( ()=>{freeze=false}
                            )
                    .start();
                }

        }
        var keymap=[];
        function multiple_key(event){  
            let c=event.keyCode; 
            console.log(c)   
            if(c==79 && mode=="3d" && all_objet==false){
                for(let i=0;i<liste_objets.length/2;i++){
                    liste_objets[i].prise(liste_objets[i].L,liste_objets[i].C);
                    objets.ranger(liste_objets[i]);
                    Laby[liste_objets[i].L][liste_objets[i].C]=0;
                    
                };
                all_objet=true;
                return false;
            }

             if((c==97 || c==98 || c==99 || c==100 || c==101) && mode=="3d"){
                let s=liste_stel[c-97];
                let ou=free_next(s.L,s.C);
                console.log(ou)
                pos_l=ou[0];
                pos_c=ou[1];
                controls.enabled=false;                           
                camera.position.set( -dim1/2+1*ou[1], save_position.y, -dim2/2+1*ou[0]+0.5 );                  
                spotLight.position.set( camera.position.x,  camera.position.y,  camera.position.z );             
                camera.rotation.y=save_position.rotation;
                camera.rotation.x=0;
                camera.rotation.z=0;
                scene.remove(light_controls)
                scene.fog=new THREE.Fog("#000000", 0.0025, 5);                               
                mode="laby";
                for(let i=0;i<liste_stel.length;i++){                   
                    liste_stel[i].scale.x=liste_stel[i].scale.y=liste_stel[i].scale.z=liste_stel[i].save_scale
                }
                for(let i=0;i<liste_objets.length;i++){                   
                    liste_objets[i].scale.x=liste_objets[i].scale.y=liste_objets[i].scale.z=liste_objets[i].save_scale
                }
                for(let i=0;i<liste_mom.length;i++){                    
                    liste_mom[i].scale.x=liste_mom[i].scale.y=liste_mom[i].scale.z=liste_mom[i].save_scale
                }

                

            }
                          
            if(mode=="3d"){               
                controls.enabled=false;                           
                camera.position.set( save_position.x, save_position.y, save_position.z );
                camera.rotation.y=save_position.rotation;
                camera.rotation.x=0;
                camera.rotation.z=0;
                scene.remove(light_controls)
                scene.fog=new THREE.Fog("#000000", 0.0025, 5);                                
                mode="laby";
                for(let i=0;i<liste_stel.length;i++){                   
                    liste_stel[i].scale.x=liste_stel[i].scale.y=liste_stel[i].scale.z=liste_stel[i].save_scale
                }
                for(let i=0;i<liste_objets.length;i++){                   
                    liste_objets[i].scale.x=liste_objets[i].scale.y=liste_objets[i].scale.z=liste_objets[i].save_scale
                }
                for(let i=0;i<liste_mom.length;i++){                    
                    liste_mom[i].scale.x=liste_mom[i].scale.y=liste_mom[i].scale.z=liste_mom[i].save_scale
                }
            }
            if(mode=="enigme"){return false}
                      
            if(c==37 || c==39 || c==38 || c==40){
                keymap=[]
            } else {
                keymap.push(c);
            }
            if(keymap[0]==77 && keymap[1]==79 && keymap[2]==77 && keymap[3]==73 && keymap[4]==69 && mode=="laby"){
                mode="3d";
                save_position={"x":camera.position.x,
                                "y":camera.position.y,
                                "z":camera.position.z,
                                "rotation":Number(camera.rotation.y),
                                //"look_at":camera.getWorldDirection()
                                }                             
                controls = new THREE.OrbitControls( camera );  
                controls.enableKeys=false
                light_controls= new THREE.AmbientLight( 0xFFFFFF ); 
                scene.add( light_controls );  
                scene.fog=null                 
                camera.position.set( 0, 50, 0 );
                camera.lookAt(new THREE.Vector3( 0, 0, 0 ))
                controls.update();
                keymap=[];
                for(let i=0;i<liste_stel.length;i++){
                    liste_stel[i].save_scale=liste_stel[i].scale.x;
                    liste_stel[i].scale.x=liste_stel[i].scale.y=liste_stel[i].scale.z=liste_stel[i].scale.x*1.5
                }
                for(let i=0;i<liste_objets.length;i++){
                    liste_objets[i].save_scale=liste_objets[i].scale.x;
                    liste_objets[i].scale.x=liste_objets[i].scale.y=liste_objets[i].scale.z=liste_objets[i].scale.x*3
                }
                for(let i=0;i<liste_mom.length;i++){
                    liste_mom[i].save_scale=liste_mom[i].scale.x;
                    liste_mom[i].scale.x=liste_mom[i].scale.y=liste_mom[i].scale.z=liste_mom[i].scale.x*3
                }

            }
           
            
        }


        function keyPressed(event) {  
            //console.log(event.keyCode) 
            //console.log(camera.rotation.y) 
           // console.log(camera.getWorldDirection())  
                            
            if(mode=="enigme" || mode=="3d"){return false}           
            if(freeze==false){
                objets.prendre.alpha= objets.utiliser.alpha=0.3;
                freeze=true;                   
                switch(event.keyCode) {
                    case 32:{
                        debug_laby();
                        freeze=false;
                        break;
                    }

                    case 37:{                        
                        let f=camera.rotation.y+3.1415/2;
                        rotation+=90
                        if(rotation>180){rotation=-90}
                        tw=new TWEEN.Tween( { y:camera.rotation.y   } )
                                .to( { y:f }, 250 )
                                .onUpdate( function () {                               
                                camera.rotation.y = this.y;
                                } )
                                .onComplete( ()=>{freeze=false}
                                    )
                            .start();

                    break;}
                        
                    case 39:{
                        rotation-=90
                        if(rotation<-90){rotation=180}
                        let f=camera.rotation.y-3.1415/2;
                        tw=new TWEEN.Tween( { y:camera.rotation.y   } )
                                .to( { y:f }, 250 )
                                .onUpdate( function () {                               
                                camera.rotation.y = this.y;
                                } )
                                .onComplete( ()=>{freeze=false}
                                    )
                            .start();

                    break;}
                        
                    case 38:{  
                        if(collision(rotation)=="obj" && premier_objet==true){                            
                            return false;
                        }                          
                        if((collision(rotation)=="rien" || collision(rotation)=="obj") ){      
                            
                            let f1=camera.position.z
                            let f2=camera.position.x                            

                            if(rotation==0){                            
                                f1=camera.position.z-1;
                                pos_l--;
                            }
                            if(rotation==180){                            
                                f1=camera.position.z+1;
                                pos_l++;
                            }
                            if(rotation==90){                            
                                f2=camera.position.x-1; 
                                pos_c--;
                            }
                            if(rotation==-90){                            
                                f2=camera.position.x+1;  
                                pos_c++;
                            }
                         
                            tw=new TWEEN.Tween( { z:camera.position.z,x:camera.position.x  } )
                                    .to( { z:f1,x:f2 }, 250 )
                                    .onUpdate( function () {                               
                                    camera.position.z = this.z;
                                    spotLight.position.z=this.z;
                                    camera.position.x = this.x;
                                    spotLight.position.x=this.x;
                                    } )
                                    .onComplete( ()=>{
                                        freeze=false;
                                        if(pos_l==0 && pos_c==1){
                                        console.log("sortie")  ;
                                        freeze=true;
                                        mode="enigme";
                                        let fin_good=page_victoire();
                                        Main_enigme.addChild(fin_good);
                                        eng.style.zIndex=4000;
                                        freeze=true;
                                        setTimeout(fin_good.cfini,2000)  
                                        clearInterval(montre);                                                                            
                                        }
                                    }
                                        )
                                .start();
                        } else {
                            //debug_laby();
                            let enface_l=enface().l;
                            let enface_c=enface().c;                            
                            if(Laby[enface_l][enface_c]==4){
                                createjs.Tween.get(phara).to({x:750},500).call(trouve_stele);
                                                                    
                            }
                            if(Laby[enface_l][enface_c]==3){
                                let e=get_momie(enface_l,enface_c).enigme;                                   
                                let b=dialogue(e[0],"momie",[e[1]],["#fc00ed"],["suite"]);
                                b.x=20;
                                b.y=20;            
                                b.addEventListener("faux",()=>{tremble=0.3;temps-=60;});
                                b.addEventListener("vrai",()=>{                                        
                                    get_momie(enface_l,enface_c).clear(b,enface_l,enface_c);
                                });
                                Main_enigme.addChild(b)                                    
                            }
                            if(collision(rotation)=="obj"){                                                                      
                                objets.prendre.alpha=1;
                            }

                            if(Laby[enface_l][enface_c]==6){
                               console.log("porte")
                                                                    
                            }                            
                           

                            if(Laby[enface_l][enface_c]==1 || Laby[enface_l][enface_c]==6){
                            freeze=false
                            }
                        }
                    
                    break;}
                    case 40:{
                        objets.prendre.alpha= objets.utiliser.alpha=0.3;
                        let r;
                        if(rotation==90 || rotation==-90){r=-rotation}
                        if(rotation==0){r=180}
                        if(rotation==180){r=0}
                        if(collision(r)=="rien" || collision(rotation)=="obj"){
                            //Laby[pos_l][pos_c]=0;
                            let f1=camera.position.z
                            let f2=camera.position.x                            

                            if(rotation==0){                            
                                f1=camera.position.z+1;
                                pos_l++;
                            }
                            if(rotation==180){                            
                                f1=camera.position.z-1;
                                pos_l--;
                            }
                            if(rotation==90){                            
                                f2=camera.position.x+1; 
                                pos_c++;
                            }
                            if(rotation==-90){                            
                                f2=camera.position.x-1;  
                                pos_c--;
                            }
                            //Laby[pos_l][pos_c]=2;
                            //debug_laby();
                            tw=new TWEEN.Tween( { z:camera.position.z,x:camera.position.x  } )
                                    .to( { z:f1,x:f2 }, 250 )
                                    .onUpdate( function () {                               
                                    camera.position.z = this.z;
                                    spotLight.position.z=this.z;
                                    camera.position.x = this.x;
                                    spotLight.position.x=this.x;
                                    } )
                                    .onComplete( ()=>{freeze=false}
                                        )
                                .start();
                        } else {freeze=false}
                    
                    break;}
                    default: freeze=false;
                }
            }
            
            if(detect_objet(rotation)){
                objets.prendre.alpha=1;
                if(premier_objet==true){
                    freeze=true;
                    premier_objet=false;
                    objets.prendre.alpha=0.3;
                    createjs.Tween.get(phara).to({x:750},500);
                    first_objet();                                                                    
                    }
            } else {

                if(detect_porte(rotation)){
                mode="porte"                
                } else {
                    mode="laby"
                }
            }
        }
            
        function collision(dir){
            let obstacle="rien"
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]!=0){obstacle="mur"};break;
                case -90: if(Laby[pos_l][pos_c+1]!=0){obstacle="mur"};break;
                case 90: if(Laby[pos_l][pos_c-1]!=0){obstacle="mur"};break;
                case 180: if(Laby[pos_l+1][pos_c]!=0){obstacle="mur"};break;
            }
            switch(dir){
                case 0: if(Laby[pos_l-1][pos_c]==5){obstacle="obj"};break;
                case -90: if(Laby[pos_l][pos_c+1]==5){obstacle="obj"};break;
                case 90: if(Laby[pos_l][pos_c-1]==5){obstacle="obj"};break;
                case 180: if(Laby[pos_l+1][pos_c]==5){obstacle="obj"};break;
            }
            
            return(obstacle);
            
        }

        function enface(){
            let enface_l=pos_l
            let enface_c=pos_c
            if(rotation==0){                           
                enface_l--;                                 
            }
            if(rotation==180){                            
                enface_l++;
            }
            if(rotation==90){                            
                enface_c--;
            }
            if(rotation==-90){                            
                enface_c++;
            }
            return({l:enface_l,c:enface_c});
        }
            
  
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // fonction de rendu  
        function render() {
            requestAnimationFrame( render );   
            //renderer.render(backgroundScene , backgroundCamera );
            renderer.render( scene, camera );
            TWEEN.update();
            if(tremble>0){                   
                camera.position.x=-dim1/2+1*pos_c+tremble*Math.cos(6.28*Math.random());
                camera.position.z=-dim2/2+1*pos_l+0.5+tremble*Math.cos(6.28*Math.random());                
                tremble=tremble-0.01
                if(first_perte){
                   // erreur();
                   // first_perte=false
                }
                }     
            if(tremble2>0){      
                Main_enigme.x=tremble2*Math.cos(6.28*Math.random());
                Main_enigme.y=tremble2*Math.cos(6.28*Math.random());
                tremble2=tremble2-0.1
                if(first_perte){
                    erreur();
                    first_perte=false
                }
                }     
            
        }   
        
        function erreur(){
            createjs.Tween.get(phara).to({x:750},500).call(()=>{
                eng.style.zIndex=1000;
                let b=dialogue(perte,"qcm",["J'ai compris."],["#fc00ed"],["suite"]);
                b.x=640;
                b.y=330;            
                b.addEventListener("suite",()=>{                
                    b.clear();
                    eng.style.zIndex=4000;
                    createjs.Tween.get(phara).wait(300).to({x:1000},500);})
                Main_control.addChild(b)
                
            });
        }
        
        /////////////////////////////// fonction de debu Laby
        function debug_laby(){ 
            for(let i=0;i<Laby.length;i++){
                    let l=""
                    for(let j=0;j<Laby.length;j++){
                        l=l+Laby[i][j];
                    } 
                    console.log(l)
                }
        }
                        
           
            
		</script>
        
    <canvas id="texture_maker" width="512" height="1024" style="display:none; background-color:#D4D4D4"></canvas>
    <canvas id="controleur" width="200" height="400" style="position: absolute; z-index: 2000;"></canvas>
    <canvas id="inv" width="735" height="60" style="position: absolute; z-index: 3000;"></canvas>
    <div id="enigme" style="position: absolute;">
        <canvas id="eng" width="800" height="400" style="position: absolute; z-index: 1000;"></canvas>        
        <form id="reponse" class="popup">
        Réponse:<input class="champ" id="contenu" type="text" name="fname" maxlength="12">
        <input id="envoyer" class="bouton" type="button" value="OK">
    </form> 
    </div>
    <p class="chrono" id="chr">Temps: </p>        
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="position: absolute; right:0"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /></a>.
    
    </body>
    
</html>